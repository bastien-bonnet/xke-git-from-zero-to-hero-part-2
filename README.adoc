= Giv from zero to hero: 2
:Author: Bastien Bonnet, Alexandre Dergham
:toc:
:numbered: 1

TODO
Avant le XKE, envoyer les pré-requis ET le descriptif de l'atelier par email.

== Pré-requis :

Récupérer le projet en local

	git clone https://github.com/bastien-bonnet/xke-git-from-zero-to-hero-part-2.git

Se placer dans le répertoire du projet cloné :

	cd xke-git-from-zero-to-hero-part-2

Visualiser l'historique sous forme de graphe compact :

	git config alias.l 'log --graph --oneline --color --decorate --all'


== Introduction
Programme du slot :

* merge et rebase
* manipulation et “deplacement” de commit
* cas pratiques rencontrés en projets

TODO faire le parallele avec java pour la notion de référencement d’objets et de garbage collector.
Un commit est immutable => on ne supprime jamais un commit mais on peut perdre sa visibilité par déréférencement (git reset ou git rebase).


TODO ajouter une image pour illustrer l’immutabilité dans la partie rebase du hand’s on.

== Consignes

=== Merge (reprise du précédent)
* positionner HEAD sur master : `git checkout master`
* creer une branche `git branch ma-branche` puis `git checkout ma-branche` (par la suite, vous obtiendrez le même résultat avec la commande `git checkout -b ma-branche`)
* modifier un fichier puis commiter : `git add .` puis `git commit -m "modif dans ma branche"`
* retour sur la branche master : `git checkout master`
* modifier un autre fichier puis commiter : `git add .` puis `git commit -m "modif dans le master"`
* merge de la branche sur master : `git merge ma-branche`
* affichage de l'arbre des commits : `git l`

[NOTE]
====
La commande merge résout les conflits en prenant pour référence le dernier commit (autrement dit, le dernier état du code source) de chaque branche.
====

=== Résolution de conflit (reprise du précédent)
TODO

=== Rebase
* positionner HEAD sur master : `git checkout master`
* creer une branche puis se positionner dessus :  `git checkout -b mon-autre-branche`
* modifier un fichier puis commiter : `git add .` puis `git commit -m "modif dans ma branche"`
* retour sur la branche master : `git checkout master`
* modifier un autre fichier puis commiter : `git add .` puis `git commit -m "modif dans le master"`
* rebase de la branche sur master : `git checkout mon-autre-branche` puis `git rebase master`
* affichage de l'arbre des commits : `git l`

[NOTE]
====
la commande rebase applique les modifications de chaque commit de la branche courante sur la cible. Ces modifications sont traitées commit par commit. Ce qui veut dire qu'on résout les merges et leurs conflits commit par commit au lieu de comparer l'état final d'une branche avec celle d'une autre (comme le ferait la commande merge).

La commande rebase ne déplace pas une branche, cette commande recrée de nouveaux commits en appliquant les modifications successives d’une branche sur un autre commit (référencé par une branche, tag ou sa clé SHA1).

Une fois les commits créées, la référence de la branche est déplacée sur ces commits, ce qui donne l’illusion que la branche a été déplacée.
Si on rajoute une autre référence de branche sur la branche “rebasée”, alors les commits restent référencés après le rebase et restent visibles.
====

=== Identifier un commit
Il existe plusieurs façons d’identifier un commit dans une commande git :

* nom de la branche associée, par exemple `git checkout ma-branche` que vous connaissez déjà.
* identifiant du commit. Il s'agit de la clé SHA1 du commit (visible avec certaines commandes comme  `git reflog`, `git log` ou notre alias `git l`)
* Relativement à un autre commit en utilisant les operateurs ~ et ^: 
** 1 commit antérieur au HEAD sur son 1er parent : `HEAD~` ou `HEAD^`
** 2 commits antérieur à HEAD sur son 1er parent: `HEAD~~` ou `HEAD~2`
** 42 commits antérieurs à HEAD sur son 1er parent: `HEAD~42`
** 1 commit antérieur à HEAD sur le 2ème parent (et oui! En cas de merge, un commit peut avoir 2 parents ^^): `HEAD^2`
** 3 commits antérieurs à HEAD sur le 2ème parent: `HEAD~3^2`
** 1 commit antérieur au dernier commit de ma-branche : `ma-branche~` (oui! ça aussi, c'est possible!)

Utilisez git checkout avec chacune des 3 façons

=== rebase -i
* positionner HEAD sur master (checkout master)
* modifier un fichier A et commiter (c1)
* modifier un fichier B et commiter avec un mauvais message (c2)
* modifier le fichier A et commiter (c3)
* modifier les fichiers C et D et commiter (c4)
* `rebase -i HEAD~4`
** deplacer c3 après c1 et fixup de c3 => modifier l’ordre et fusionner les commit
** reword c2
** edit c4 : séparer les modifs des fichiers C et D en 2 commits

=== rebase --onto
TODO

=== Revenir en arrière : la différence entre checkout, reset et revert

==== Reset
reset deplace une référence de branche sans modifier le contenu du fileSystem

utilisation de base de reset :

* git checkout master (on appelera par la suite ce commit C0)
* modifier fichier A et commiter (c1)
* `git reset HEAD~1` (C0 si vous avez bien suivi)
* git status
+
La référence de la branche master s’est déplacée d’un commit en arrière (C0) mais le file system reste dans l’état du commit C1. Du coup, git status considère l’état actuel du file system comme différent de son commit actuel.
* git diff
+
vous voyez la différence entre le commit et l’état du fileSystem
Note : si vous voulez déplacer une référence de commit vers un commit Cx et rétablir le file system à l’état du commit Cx, utiliser git reset --hard

On peut retrouver la clé SHA1 d’un commit perdu avec à git reflog

On peut rétablir un commit perdu si on connait sa clé SHA1  (git checkout mySHA1  puis git branch).

utilisation de reset pour rétablir une version antérieure:

* git reflog pour faire apparaitre le commit C1 que nous venons de déréférencer.
* git reset sur la clée SHA1 de C1=> master est repositionné sur ce commit 

==== Revert
utilisation de revert pour créer un commit de restauration.
git revert C0  => on crée un nouveau commit après C1 qui inverse les modifs de C0 vers C1.

==== Checkout
TODO


== Mises en situation

=== Situation 1
rebase d’une branche sur une autre pour valider l’intégration de 2 features sans faire de merge.

=== Situation 2
je dev un commit sur la master:

* git checkout -b pour rajouter une référence sur ce commit
* git checkout master 
* `git reset HEAD~1`

On a rétabli le master à sa version origin tout en maintenant le dev qui a été produit.

=== Situation 3
je crée une branche B2 sur la branche  B1 au lieu de master :

* si on fait un rebase de B2 sur master, alors B1 est rebase sur master
* la solution est d’utiliser rebase --onto

=== Situation 4
utilisation de git reflog puis git reset --hard pour restaurer l’arborescence à un état antérieur.

