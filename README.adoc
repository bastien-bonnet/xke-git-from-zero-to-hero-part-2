= Giv from zero to hero: 2
:Author: Bastien Bonnet, Alexandre Dergham
:toc:
:numbered: 1

TODO
Avant le XKE, envoyer les pré-requis ET le descriptif de l'atelier par email.

== Pré-requis :

* Récupérer le projet en local

	git clone https://github.com/bastien-bonnet/xke-git-from-zero-to-hero-part-2.git

* Se placer dans le répertoire du projet cloné :

	cd xke-git-from-zero-to-hero-part-2

* Pour visualiser l'historique des commits sous forme de graphe compact, nous rajoutons un nouvel alias) :

	git config alias.l 'log --graph --oneline --color --decorate --all'


== Introduction
Programme du slot :

* merge et rebase
* manipulation et “deplacement” de commit
* cas pratiques rencontrés en projets

TODO faire le parallele avec java pour la notion de référencement d’objets et de garbage collector.
Un commit est immutable => on ne supprime jamais un commit mais on peut perdre sa visibilité par déréférencement (git reset ou git rebase).


TODO ajouter une image pour illustrer l’immutabilité dans la partie rebase du hand’s on.

== Consignes

=== Merge (reprise du précédent)
* positionner HEAD sur master : `git checkout master`
* creer une branche `git branch ma-branche` puis `git checkout ma-branche` (par la suite, vous obtiendrez le même résultat avec la commande `git checkout -b ma-branche`)
* modifier un fichier puis commiter : `git add .` puis `git commit -m "modif dans ma branche"`
* retour sur la branche master : `git checkout master`
* modifier un autre fichier puis commiter : `git add .` puis `git commit -m "modif dans le master"`
* merge de la branche sur master : `git merge ma-branche`
* affichage de l'arbre des commits : `git l`

[NOTE]
====
La commande merge résout les conflits en prenant pour référence le dernier commit (autrement dit, le dernier état du code source) de chaque branche.
====

=== Résolution de conflit (reprise du précédent)
TODO

=== Rebase
* positionner HEAD sur master : `git checkout master`
* creer une branche puis se positionner dessus :  `git checkout -b mon-autre-branche`
* modifier un fichier puis commiter : `git add .` puis `git commit -m "modif dans ma branche"`
* retour sur la branche master : `git checkout master`
* modifier un autre fichier puis commiter : `git add .` puis `git commit -m "modif dans le master"`
* rebase de la branche sur master : `git checkout mon-autre-branche` puis `git rebase master`
* affichage de l'arbre des commits : `git l`

[NOTE]
====
la commande rebase applique les modifications de chaque commit de la branche courante sur la cible. Ces modifications sont traitées commit par commit. Ce qui veut dire qu'on résout les merges et leurs conflits commit par commit au lieu de comparer l'état final d'une branche avec celle d'une autre (comme le ferait la commande merge).

La commande rebase ne déplace pas une branche, cette commande recrée de nouveaux commits en appliquant les modifications successives d’une branche sur un autre commit (référencé par une branche, tag ou sa clé SHA1).

Une fois les commits créées, la référence de la branche est déplacée sur ces commits, ce qui donne l’illusion que la branche a été déplacée.
Si on rajoute une autre référence de branche sur la branche “rebasée”, alors les commits restent référencés après le rebase et restent visibles.
====

=== Identifier un commit
Il existe plusieurs façons d’identifier un commit dans une commande git :

* nom de la branche associée, par exemple `git checkout ma-branche` que vous connaissez déjà.
* identifiant du commit. Il s'agit de la clé SHA1 du commit (visible avec certaines commandes comme  `git reflog`, `git log` ou notre alias `git l`)
* Relativement à un autre commit en utilisant les operateurs ~ et ^: 
** 1 commit antérieur au HEAD sur son 1er parent : `HEAD~` ou `HEAD^`
** 2 commits antérieur à HEAD sur son 1er parent: `HEAD~~` ou `HEAD~2`
** 42 commits antérieurs à HEAD sur son 1er parent: `HEAD~42`
** 1 commit antérieur à HEAD sur le 2ème parent (et oui! En cas de merge, un commit peut avoir 2 parents ^^): `HEAD^2`
** 3 commits antérieurs à HEAD sur le 2ème parent: `HEAD~3^2`
** 1 commit antérieur au dernier commit de ma-branche : `ma-branche~` (oui! ça aussi, c'est possible!)

Vous pouvez prendre 5 minutes et jouer avec la commande `git checkout` en utilisant ces méthodes de identification de commit.

=== rebase --interactive ou rebase -i
Cette commande vous permetra de réécrire l'histoire de votre code source.

* positionner HEAD sur master : `git checkout master`
* modifier un fichier A et commiter : `git add .` puis `git commit -m "c1"` 
* modifier un fichier B et commiter avec un mauvais message : `git add .` puis `git commit -m "c2 with bad message"` 
* modifier le fichier A et commiter : `git add .` puis `git commit -m "c3"` 
* modifier les fichiers C et D et commiter : `git add .` puis `git commit -m "c4"` 
* initier la réécriture de histoire des 4 derniers commits : `rebase -i HEAD~4`
* un texte apparait à l'écran et est edité par vim. Les 4 premières lignes de ce text représente les 4 derniers commits que vous venez de faire. Ces commits sont identifiés par une clé SHA1 et une commande d'action par défaut `pick`. Ceci veut dire que dans l'état, l'historique de vos sources tiennent compte de ces 4 commits en l'état. A partir de là, il est possible d'effectuer les actions suivantes :
** déplacer le commit c3 juste en dessous de c1 et déplaçant toute la ligne qui fait référence à c3. Cela aura pour effet de modifier l'ordre des commits dans l'historique.
** fusionner c1 et c3 en conservant le message de commit de c1. Pour cela, il vous suffit de remplacer le mot clé `pick` par `f` ou `fixup` à la ligne correspondant au commit c3 après l'avoir déplacé en dessous de c1.
** Pour corriger le message de commit de c2, il faut remplacer le mot clé `pick` par `r` ou `reword` devant ce commit 
** Pour séparer c4 en 2 commits : remplacer le mot clé `pick` par `e` ou `edit` devant ce commit. Cela indique qu'au moment de réécrire l'historique, git interrompera sa réécriture pour vous rendre la main et vous permettre de modifier le commit c4.
** une fois le texte modifié, sauvegarder le document en cours d'édition.
* git va reconstruire une nouvelle branche en prenant les différents commits que vous avez listés dans le document et en leur appliquant les différentes opérations que vous avez déclarées (fixup, reword et edit).
* une fois c1 et c3 fusionnés automatiquement fusionnés par git, celui-ci vous invite à ressaisir le texte de commit de c2
* une fois le texte de c2 saisi et enregistré, git inclut le commit c4 à la nouvelle branche mais ne finalise pas la réécriture d'historique. Vous avez la main pour faire les actions suivantes :
** `git l`: vous constatez qu'une nouvelle branche est en cours de création mais qu'elle ne porte pas encore de référence.
** deplacer la référence de HEAD au commit précédent sans modifier le système de fichiers : `git reset HEAD~`
** constater que les fichiers C et D sont modifiés par rapport au commit courant (c2 si vous avez bien suivi) : `git status`
** créer un commit spécifique pour le fichier C : `git add C` puis `git commit -m "c4.1"` 
** créer un commit spécifique pour le fichier D : `git add D` puis `git commit -m "c4.2"`
** une fois les 2 commits créés, vous devez indiquer à git que la réécriture d'histoire est terminée : `git rebase --continue`
* `git l` : la référence de la branche master a été déplacée sur le dernier commit de votre nouvelle branche.

=== rebase --onto
TODO

=== Revenir en arrière : la différence entre checkout, reset et revert

==== Reset
reset deplace une référence de branche sans modifier le contenu du système de fichier

utilisation de base de reset :

* `git checkout master` (on appelera par la suite ce commit r0)
* modifier fichier A et commiter : `git add .` puis `git commit -m "r1"` 
* `git reset HEAD~1` (r0 si vous avez bien suivi)
* `git status
+
La référence de la branche master s’est déplacée d’un commit en arrière (c0) mais le file system reste dans l’état du commit C1. Du coup, git status considère l’état actuel du file system comme différent de son commit actuel.
* git diff
+
vous voyez la différence entre le commit et l’état du fileSystem
Note : si vous voulez déplacer une référence de commit vers un commit Cx et rétablir le file system à l’état du commit Cx, utiliser git reset --hard

On peut retrouver la clé SHA1 d’un commit perdu avec à git reflog

On peut rétablir un commit perdu si on connait sa clé SHA1  (git checkout mySHA1  puis git branch).

utilisation de reset pour rétablir une version antérieure:

* git reflog pour faire apparaitre le commit C1 que nous venons de déréférencer.
* git reset sur la clée SHA1 de C1=> master est repositionné sur ce commit 

==== Revert
utilisation de revert pour créer un commit de restauration.
git revert C0  => on crée un nouveau commit après C1 qui inverse les modifs de C0 vers C1.

==== Checkout
TODO


== Mises en situation

=== Situation 1
rebase d’une branche sur une autre pour valider l’intégration de 2 features sans faire de merge.

=== Situation 2
je dev un commit sur la master:

* git checkout -b pour rajouter une référence sur ce commit
* git checkout master 
* `git reset HEAD~1`

On a rétabli le master à sa version origin tout en maintenant le dev qui a été produit.

=== Situation 3
je crée une branche B2 sur la branche  B1 au lieu de master :

* si on fait un rebase de B2 sur master, alors B1 est rebase sur master
* la solution est d’utiliser rebase --onto

=== Situation 4
utilisation de git reflog puis git reset --hard pour restaurer l’arborescence à un état antérieur.

