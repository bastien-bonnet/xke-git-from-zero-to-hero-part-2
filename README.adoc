= Giv from zero to hero: 2
:Author: Bastien Bonnet, Alexandre Dergham
:toc:
:numbered: 1

TODO
Avant le XKE, envoyer les pré-requis ET le descriptif de l'atelier par email.

== Pré-requis :

Récupérer le projet en local

	git clone https://github.com/bastien-bonnet/xke-git-from-zero-to-hero-part-2.git

Se placer dans le répertoire du projet cloné :

	cd xke-git-from-zero-to-hero-part-2

Visualiser l'historique sous forme de graphe compact :

	git config alias.l 'log --graph --oneline --color --decorate --all'


== Introduction
Programme du slot :

* merge et rebase
* manipulation et “deplacement” de commit
* cas pratiques rencontrés en projets

TODO faire le parallele avec java pour la notion de référencement d’objets et de garbage collector.
Un commit est immutable => on ne supprime jamais un commit mais on peut perdre sa visibilité par déréférencement (git reset ou git rebase).


TODO ajouter une image pour illustrer l’immutabilité dans la partie rebase du hand’s on.

== Consignes

=== Merge (reprise du précédent)
* positionner HEAD sur master (checkout master)
* creer une branche git branch puis git checkout (ou git checkout -b)
* modifier un fichier puis commiter
* checkout master
* modifier un autre fichier puis commiter
* merge de la branche sur master
* git lola

[NOTE]
====
merge résout les conflit en prenant pour référence le dernier commit de chaque branche.
====

=== Résolution de conflit (reprise du précédent)
TODO

=== Rebase
* positionner HEAD sur master (checkout master)
* creer une branche git branch puis git checkout (ou git checkout -b)
* modifier un fichier puis commiter
* checkout master
* modifier un autre fichier puis commiter
* rebase de la branche sur master
* git lola

[NOTE]
====
rebase applique chaque commit de la branche un par un -> on résout les merges commit par commit.

++ : rebase ne déplace pas une branche, cette commande recrée de nouveaux commits en appliquant les modifications successives d’une branche sur un autre commit (pas nécessairement une branche ou un tag).
Une fois les commits créées, la référence de la branche est déplacée sur les ces commits, ce qui donne l’illusion que la branche a été déplacée.
Si on rajoute une autre référence de branche sur la branche “rebasée”, alors les commits restent référencés après le rebase et restent visibles.
====

=== Identifier un commit
Plusieurs façons d’identifier un commit dans une commande git :

* nom de la branche associée
* identifiant du commit (clé SHA1)
* HEAD~

Utilisez git checkout avec chacune des 3 façons

=== rebase -i
* positionner HEAD sur master (checkout master)
* modifier un fichier A et commiter (c1)
* modifier un fichier B et commiter avec un mauvais message (c2)
* modifier le fichier A et commiter (c3)
* modifier les fichiers C et D et commiter (c4)
* `rebase -i HEAD~4`
** deplacer c3 après c1 et fixup de c3 => modifier l’ordre et fusionner les commit
** reword c2
** edit c4 : séparer les modifs des fichiers C et D en 2 commits

=== rebase --onto
TODO

=== Revenir en arrière : la différence entre checkout, reset et revert : 
explication de reset : 
reset deplace une référence de branche sans modifier le contenu du fileSystem
utilisation de base de reset :
git checkout master (on appelera par la suite ce commit C0)
modifier fichier A et commiter (c1)
git reset HEAD~1 (C0 si vous avez bien suivi)
git status 
La référence de la branche master s’est déplacée d’un commit en arrière (C0) mais le file system reste dans l’état du commit C1. Du coup, git status considère l’état actuel du file system comme différent de son commit actuel.
git diff
vous voyez la différence entre le commit et l’état du fileSystem
Note : si vous voulez déplacer une référence de commit vers un commit Cx et rétablir le file system à l’état du commit Cx, utiliser git reset --hard
On peut retrouver la clé SHA1 d’un commit perdu avec à git reflog
On peut rétablir un commit perdu si on connait sa clé SHA1  (git checkout mySHA1  puis git branch).

utilisation de reset pour rétablir une version antérieure:
git reflog pour faire apparaitre le commit C1 que nous venons de déréférencer.
git reset sur la clée SHA1 de C1=> master est repositionné sur ce commit 
utilisation de revert pour créer un commit de restauration.
git revert C0  => on crée un nouveau commit après C1 qui inverse les modifs de C0 vers C1. 

== Mise en situation
rebase d’une branche sur une autre pour valider l’intégration de 2 features sans faire de merge.
je dev un commit sur la master: 
git checkout -b pour rajouter une référence sur ce commit
git checkout master 
git reset HEAD~1
on rétablit le master à sa version origin tout en maintenant le dev qui a été produit.
je crée une branche B2 sur la branche  B1 au lieu de master:
si on fait un rebase de B2 sur master, alors B1 est rebase sur master
la solution est d’utiliser rebase --onto
utilisation de git reflog puis git reset --hard pour restaurer l’arborescence à un état antérieur.

